# Аналіз розбиття mcp-abap-adt на окремі пакети

## Запропонована архітектура

### Основна мета розділення

**Ключова вимога:** Зміни в реалізації MCP функцій (handlers) **не повинні впливати** на:
- ✅ Коннект до ABAP (connection layer)
- ✅ Підключення до сервера (transport layer: SSE/STDIO/HTTP)

**Архітектура:**
```
Server = Transport Layer + ABAP Connection + Handlers (MCP функції)
```

**Переваги:**
- Зміни в handlers не вимагають змін в connection/transport
- Можна імпортувати класи handlers для пакетного створення об'єктів
- Незалежна розробка та тестування кожного шару

### Поступовий підхід (знизу вгору)

**Етап 1:** Винести нижні рівні абстракції (рекомендовано почати з цього):
1. Transport Layer (SSE/STDIO/HTTP) + інтерфейс
2. ABAP Connection + інтерфейс
3. Утіліти

**Етап 2:** Handlers залишаються в server, але використовують винесені компоненти

---

### Пакет 1: ABAP Connection Layer (`@mcp-abap-adt/connection`)
**Компоненти:**
- `BaseAbapConnection` - базова реалізація з CSRF, cookies, axios
- `OnPremAbapConnection` - базова автентифікація (Basic Auth)
- `CloudAbapConnection` - JWT автентифікація для Cloud ABAP
- `AbapConnection` - інтерфейс
- `connectionFactory` - фабрика для створення з'єднань
- `SapConfig` - типи конфігурації

**Залежності:**
- `axios` - HTTP клієнт
- `@types/node` - типи Node.js

---

### Пакет 2: Transport Layer (`@mcp-abap-adt/transport`) ⭐ ПОЧАТИ З ЦЬОГО
**Компоненти:**
- `StdioTransport` - реалізація STDIO протоколу
- `SSETransport` - реалізація Server-Sent Events  
- `StreamableHttpTransport` - реалізація Streamable HTTP
- `TransportInterface` - інтерфейс для транспортів
- `parseTransportConfig()` - парсинг конфігурації транспорту
- Логіка створення та управління транспортами

**Залежності:**
- `@modelcontextprotocol/sdk` - MCP SDK
- НЕ залежить від connection (transport працює незалежно)

**Чому почати з цього:**
- ✅ Найнижчий рівень абстракції
- ✅ Не залежить від інших компонентів
- ✅ Використовується сервером, але не залежить від handlers

---

### Пакет 3: MCP Server Core (`@mcp-abap-adt/server`)
**Компоненти:**
- `mcp_abap_adt_server` - основний клас сервера
  - Використовує: Transport Layer + ABAP Connection + Handlers
  - Координує роботу всіх компонентів
- Всі handlers (57 файлів у `src/handlers/`) - реалізація MCP функцій
  - Використовують ABAP Connection через інтерфейс
  - Можуть бути імпортовані окремо для пакетного створення
- `toolsRegistry` - реєстр інструментів
- Авторизаційні утіліти (`sessionUtils`, `activationUtils`)
- Конфігурація та логінг (`logger`, `timeouts`)

**Залежності:**
- `@modelcontextprotocol/sdk`
- `@mcp-abap-adt/connection` - через інтерфейс
- `@mcp-abap-adt/transport` - через інтерфейс
- `@mcp-abap-adt/utils` (опціонально)

**Архітектура:**
```typescript
class mcp_abap_adt_server {
  private transport: TransportInterface;      // з @mcp-abap-adt/transport
  private connection: AbapConnection;        // з @mcp-abap-adt/connection
  private handlers: Map<string, Handler>;     // локальні handlers
  
  // Зміни в handlers НЕ впливають на transport/connection
}
```

---

### Пакет 4: Utilities (`@mcp-abap-adt/utils`)
**Компоненти:**
- Пакетне створення об'єктів
  - Імпортує класи handlers для використання функцій
  - Використовує ABAP Connection через інтерфейс
- Зняття вмісту для пакетного створення
- Кешування (`getFullCodeCache`, `getObjectsListCache`)
- Допоміжні функції (`utils.ts`, `writeResultToFile`)
- Валідація транспорту (`transportValidation`)

**Залежності:**
- `@mcp-abap-adt/connection` - для роботи з ABAP (через інтерфейс)
- `@mcp-abap-adt/server` - для імпорту handlers (опціонально)

**Приклад використання для пакетного створення:**
```typescript
import { AbapConnection } from '@mcp-abap-adt/connection';
import { handleCreateClass } from '@mcp-abap-adt/server/handlers';

// Використання handler функції для пакетного створення
async function batchCreateClasses(connection: AbapConnection, classes: string[]) {
  for (const className of classes) {
    await handleCreateClass({ name: className, ... }, connection);
  }
}
```

---

## Плюси розбиття

### 1. Ізоляція змін (Основна мета) ⭐
✅ **Зміни в handlers НЕ впливають на connection/transport**
- Додавання нових MCP функцій не вимагає змін в ABAP connection
- Зміни в логіці обробки не впливають на transport layer
- Незалежна розробка та тестування кожного шару

✅ **Зміни в connection НЕ впливають на transport/handlers**
- Оновлення автентифікації не вимагає змін в transport
- Зміни в ABAP API не впливають на handlers (через інтерфейс)

✅ **Зміни в transport НЕ впливають на connection/handlers**
- Додавання нового протоколу не вимагає змін в connection
- Зміни в транспортному шарі не впливають на бізнес-логіку

### 2. Модульність та перевикористання
✅ **Connection layer** можна використовувати окремо в інших проектах
- Інтеграції з ABAP без MCP
- CLI інструменти для роботи з ABAP
- Тестування ABAP API незалежно від MCP

✅ **Transport layer** можна замінити або розширити
- Додавання нових протоколів (WebSocket, gRPC)
- Використання connection layer з іншими протоколами

✅ **Handlers можна імпортувати окремо**
- Пакетне створення об'єктів через імпорт handler функцій
- Використання MCP функцій без повного сервера

### 2. Незалежна розробка та версіонування
✅ Кожен пакет має власний цикл релізів
- `connection` - стабільний, рідко змінюється
- `server` - активна розробка, часті оновлення
- `utils` - можна розвивати окремо

✅ Можливість паралельної розробки
- Різні команди працюють над різними пакетами
- Менше конфліктів у git

### 3. Тестування
✅ Легше тестувати окремі компоненти
- Connection layer тестується без MCP сервера
- Transport layer тестується з mock connection
- Handlers тестуються з mock connection

✅ Можливість unit-тестів для кожного пакету окремо

### 4. Розмір бандлів
✅ Менші залежності для клієнтів
- Якщо потрібен тільки connection - тільки один пакет
- Якщо потрібен тільки server - менше залежностей

### 5. Документація та API
✅ Чіткі межі між компонентами
- Кожен пакет має власний API
- Легше документувати окремі модулі

---

## Мінуси розбиття

### 1. Складність управління залежностями
❌ **Версіонування між пакетами**
- Потрібен monorepo tool (npm workspaces, pnpm workspaces, lerna, nx)
- Координація версій між пакетами
- Breaking changes в одному пакеті впливають на інші

❌ **Circular dependencies**
- `server` залежить від `connection` та `transport`
- `transport` може залежати від `connection`
- Потрібна ретельна архітектура

### 2. Трудозатратність міграції
❌ **Рефакторинг існуючого коду**
- Розбиття `src/index.ts` (981 рядок) на окремі пакети
- Перенесення 57 handlers
- Оновлення всіх імпортів
- Оновлення тестів

❌ **Налаштування monorepo**
- Створення структури пакетів
- Налаштування build системи
- Налаштування CI/CD для кількох пакетів

### 3. Складність розробки
❌ **Локальна розробка стає складнішою**
- Потрібно встановлювати залежності між пакетами
- `npm link` або `pnpm link` для локальної розробки
- Більше кроків для запуску проекту

❌ **Debugging ускладнюється**
- Код розкиданий по різним пакетам
- Складніше відстежувати виклики між пакетами

### 4. Overhead для малих проектів
❌ **Over-engineering для поточного розміру**
- Проект має ~57 handlers, що не критично велико
- Можливо, монолітна структура достатня зараз

❌ **Додаткові витрати на підтримку**
- Більше репозиторіїв/пакетів для підтримки
- Більше конфігураційних файлів
- Складніший процес релізів

### 5. Проблеми з TypeScript
❌ **Project references та paths**
- Потрібна налаштування TypeScript project references
- Можливі проблеми з type resolution
- Складніша конфігурація tsconfig

### 6. Тестування інтеграції
❌ **Складніше тестувати інтеграцію**
- Потрібні integration тести між пакетами
- Можливі проблеми з версіями під час тестування

---

## Оцінка трудозатратності

### Фаза 1: Підготовка monorepo структури
**Час: 2-3 дні**

1. Налаштування monorepo tool (pnpm workspaces рекомендовано)
   - Створення `pnpm-workspace.yaml`
   - Структура `packages/` директорії
   - Налаштування root `package.json`

2. Створення структури пакетів
   ```
   packages/
     connection/
       package.json
       tsconfig.json
       src/
     transport/
       package.json
       tsconfig.json
       src/
     server/
       package.json
       tsconfig.json
       src/
     utils/
       package.json
       tsconfig.json
       src/
   ```

3. Налаштування TypeScript project references
   - Root `tsconfig.json` з references
   - Окремі `tsconfig.json` для кожного пакету

### Фаза 2: Розбиття transport layer ⭐ ПОЧАТИ З ЦЬОГО
**Час: 2-3 дні**

**Чому почати з transport:**
- Найнижчий рівень абстракції
- Не залежить від connection або handlers
- Використовується сервером, але не залежить від бізнес-логіки

1. Виділення transport логіки з `src/index.ts`:
   - `parseTransportConfig()` → `packages/transport/src/config.ts`
   - Логіка `StdioServerTransport`, `SSEServerTransport`, `StreamableHTTPServerTransport`
   - Створення абстракції `TransportInterface`
   - Логіка створення HTTP сервера для SSE/HTTP

2. Створення `packages/transport/package.json`
   - Залежності: `@modelcontextprotocol/sdk`
   - НЕ залежить від connection

3. Створення інтерфейсу `TransportInterface`:
   ```typescript
   export interface TransportInterface {
     connect(server: Server): Promise<void>;
     close(): Promise<void>;
   }
   ```

4. Рефакторинг `mcp_abap_adt_server.run()` для використання transport layer
5. Тестування transport layer окремо

### Фаза 3: Розбиття connection layer
**Час: 1-2 дні**

1. Перенесення файлів:
   - `src/lib/connection/*` → `packages/connection/src/`
   - `src/lib/sapConfig.ts` → `packages/connection/src/`
   - `src/lib/timeouts.ts` → `packages/connection/src/` (або залишити в server)

2. Створення `packages/connection/package.json`
   - Залежності: `axios`, `@types/node`
   - НЕ залежить від transport або server

3. Оновлення експортів та імпортів
4. Тестування connection layer окремо
5. Оновлення handlers для використання connection через інтерфейс

### Фаза 4: Розбиття utilities
**Час: 1-2 дні**

1. Перенесення утіліт:
   - `src/lib/getFullCodeCache.ts` → `packages/utils/src/`
   - `src/lib/getObjectsListCache.ts` → `packages/utils/src/`
   - `src/lib/writeResultToFile.ts` → `packages/utils/src/`
   - `src/lib/utils.ts` (частково) → `packages/utils/src/`
   - `src/utils/transportValidation.ts` → `packages/utils/src/`

2. Створення функцій для пакетного створення (якщо ще немає)
   - Імпорт handler функцій з server
   - Використання connection через інтерфейс

3. Створення `packages/utils/package.json`
   - Залежності: `@mcp-abap-adt/connection` (через інтерфейс)
   - Опціонально: `@mcp-abap-adt/server` (для імпорту handlers)

### Фаза 5: Рефакторинг server core
**Час: 3-4 дні**

**Важливо:** Handlers залишаються в server, але використовують винесені компоненти

1. Рефакторинг `src/index.ts` → `packages/server/src/index.ts`:
   - Використання `TransportInterface` з `@mcp-abap-adt/transport`
   - Використання `AbapConnection` з `@mcp-abap-adt/connection`
   - Handlers залишаються локально, але використовують connection через інтерфейс

2. Перенесення handlers (залишаються в server):
   - `src/handlers/*` → `packages/server/src/handlers/`
   - 57 файлів handlers
   - Оновлення імпортів для використання connection через інтерфейс

3. Перенесення core логіки:
   - `src/lib/toolsRegistry.ts` → `packages/server/src/`
   - `src/lib/logger.ts` → `packages/server/src/`
   - `src/lib/sessionUtils.ts` → `packages/server/src/`
   - `src/lib/activationUtils.ts` → `packages/server/src/`

4. Створення `packages/server/package.json`:
   - Залежності: 
     - `@mcp-abap-adt/transport` (через інтерфейс)
     - `@mcp-abap-adt/connection` (через інтерфейс)
     - `@mcp-abap-adt/utils` (опціонально)

5. Експорт handlers для використання в utils:
   ```typescript
   // packages/server/src/handlers/index.ts
   export { handleCreateClass } from './handleCreateClass';
   export { handleCreateProgram } from './handleCreateProgram';
   // ... інші handlers
   ```

6. Оновлення entry point

### Фаза 6: Оновлення тестів
**Час: 2-3 дні**

1. Оновлення шляхів імпортів у тестах
2. Створення тестів для окремих пакетів
3. Оновлення integration тестів
4. Налаштування тестування в monorepo

### Фаза 7: Документація та CI/CD
**Час: 1-2 дні**

1. Оновлення README для кожного пакету
2. Оновлення основного README
3. Налаштування CI/CD для кількох пакетів
4. Налаштування автоматичного релізу

### Фаза 8: Тестування та виправлення помилок
**Час: 2-3 дні**

1. Повне тестування всіх сценаріїв
2. Виправлення помилок залежностей
3. Виправлення проблем з типами TypeScript
4. Тестування різних конфігурацій

---

## Загальна оцінка трудозатратності

**Мінімальна оцінка: 14-18 днів** (2.5-3.5 тижні)
**Реалістична оцінка: 20-25 днів** (4-5 тижнів)
**З буфером на непередбачені проблеми: 25-30 днів** (5-6 тижнів)

**Припущення:**
- Один розробник працює повний робочий день
- Досвід роботи з monorepo та TypeScript
- Мінімальні зміни в бізнес-логіці (тільки рефакторинг)

---

## Рекомендації

### Варто робити, якщо:
✅ Планується використання connection layer в інших проектах
✅ Очікується значне зростання кількості handlers (>100)
✅ Планується додавання нових transport протоколів
✅ Є команда розробників, які працюватимуть паралельно
✅ Є час на рефакторинг (4-6 тижнів)

### Не варто робити зараз, якщо:
❌ Проект ще на ранній стадії розвитку
❌ Немає планів на перевикористання компонентів
❌ Команда мала (1-2 розробники)
❌ Немає часу на рефакторинг
❌ Поточна монолітна структура працює добре

### Альтернативний підхід: Поступова міграція
1. **Етап 1:** Виділити connection layer в окремий пакет (найбільша цінність)
2. **Етап 2:** За потреби виділити transport layer
3. **Етап 3:** За потреби виділити utils
4. **Етап 4:** Server залишається монолітом, але використовує інші пакети

Це дозволить отримати переваги модульності без великого рефакторингу одразу.

---

## Публічність коду та ліцензування

### Поточний стан
✅ Проект має **MIT ліцензію** - код вже відкритий
✅ Репозиторій на GitHub: `git@github.com:fr0ster/mcp-abap-adt.git`
✅ Якщо репозиторій публічний - весь код доступний будь-кому

### Вплив розбиття на пакети

#### Якщо репозиторій публічний:
✅ **Всі пакети будуть публічними**
- Кожен пакет у monorepo матиме доступ до всього коду
- MIT ліцензія поширюється на всі пакети
- Будь-хто зможе встановити та використовувати окремі пакети через npm

#### Варіанти захисту (якщо потрібно):

**Варіант 1: Приватні пакети в npm**
- Опублікувати пакети як `@fr0ster/mcp-abap-adt-connection` (private)
- Потрібен npm paid plan ($7/місяць для приватних пакетів)
- Контроль доступу через npm organizations

**Варіант 2: GitHub Packages**
- Використовувати GitHub Packages (включено в GitHub)
- Пакети доступні тільки авторизованим користувачам
- Безкоштовно для публічних репозиторіїв з обмеженнями

**Варіант 3: Приватний репозиторій**
- Зробити GitHub репозиторій приватним
- Пакети доступні тільки через приватний npm registry
- Потрібна підписка GitHub Teams/Enterprise

**Варіант 4: Гібридний підхід**
- Деякі пакети публічні (connection, utils)
- Деякі пакети приватні (server з бізнес-логікою)
- Різні ліцензії для різних пакетів

### Рекомендації щодо публічності

#### Якщо код має залишатися публічним:
✅ **Залишити MIT ліцензію** - стандарт для open source
✅ **Документувати API кожного пакету** - для кращого використання
✅ **Додати CONTRIBUTING.md** - для контриб'юторів
✅ **Використовувати semantic versioning** - для передбачуваних релізів

#### Якщо потрібен контроль доступу:
⚠️ **Розглянути приватні пакети** - додаткові витрати
⚠️ **Окремий репозиторій для приватних компонентів**
⚠️ **Enterprise ліцензування** - якщо це комерційний продукт

### Вплив на архітектуру

Розбиття на пакети **не змінює публічність коду**:
- Якщо репозиторій публічний → всі пакети публічні
- Якщо репозиторій приватний → всі пакети приватні
- Monorepo структура не впливає на доступність

**Важливо:** Розбиття на пакети робить код **більш структурованим**, але не змінює його публічність автоматично.

---

## Стратегії балансу: Простота інсталяції vs Контроль розповсюдження

### Проблема
- ✅ **Хочемо:** Спростити інсталяцію через окремі npm пакети
- ⚠️ **Не хочемо:** Втратити контроль над розповсюдженням сервера

### Рекомендовані стратегії

#### Стратегія 1: Гібридний підхід (Рекомендовано) ⭐

**Концепція:** Публічні базові компоненти + Контрольований сервер

**Структура:**
```
@mcp-abap-adt/connection     → ПУБЛІЧНИЙ (MIT)
@mcp-abap-adt/transport      → ПУБЛІЧНИЙ (MIT)
@mcp-abap-adt/utils          → ПУБЛІЧНИЙ (MIT)
@mcp-abap-adt/server         → ПРИВАТНИЙ або з обмеженнями
```

**Переваги:**
- ✅ Проста інсталяція базових компонентів: `npm install @mcp-abap-adt/connection`
- ✅ Контроль над сервером через приватний пакет або ліцензування
- ✅ Розробники можуть використовувати connection/utils окремо
- ✅ Сервер залишається під контролем

**Реалізація:**
- Connection/Transport/Utils → публічні npm пакети
- Server → приватний npm пакет або GitHub Packages з обмеженнями
- Server може використовувати публічні пакети як залежності

**Інсталяція:**
```bash
# Базові компоненти - публічні
npm install @mcp-abap-adt/connection
npm install @mcp-abap-adt/transport

# Сервер - з контролем доступу
npm install @fr0ster/mcp-abap-adt-server --registry=https://npm.pkg.github.com
```

---

#### Стратегія 2: Dual Licensing

**Концепція:** Публічний код з двома ліцензіями

**Структура:**
- Всі пакети публічні в репозиторії
- MIT ліцензія для особистого використання
- Комерційна/Enterprise ліцензія для комерційного використання

**Переваги:**
- ✅ Повна прозорість коду
- ✅ Контроль через ліцензування
- ✅ Можливість монетизації

**Недоліки:**
- ⚠️ Складніше контролювати використання
- ⚠️ Потрібна юридична підтримка

**Приклад:**
```json
{
  "license": "MIT OR Commercial",
  "private": false
}
```

---

#### Стратегія 3: Публічний код + Runtime контроль

**Концепція:** Код публічний, але сервер вимагає авторизації/реєстрації

**Реалізація:**
- Всі пакети публічні
- Server вимагає API ключ або токен для роботи
- Контроль через централізований сервіс авторизації

**Переваги:**
- ✅ Проста інсталяція: `npm install @mcp-abap-adt/server`
- ✅ Контроль через авторизацію
- ✅ Можливість збору статистики використання

**Недоліки:**
- ⚠️ Потрібна інфраструктура для авторизації
- ⚠️ Залежність від зовнішнього сервісу

**Приклад:**
```typescript
// Server вимагає токен при старті
const server = new McpAbapAdtServer({
  licenseKey: process.env.MCP_LICENSE_KEY // обов'язковий
});
```

---

#### Стратегія 4: Scope-based контроль

**Концепція:** Використання npm scope для контролю

**Структура:**
```
@mcp-abap-adt/connection     → Публічний scope
@mcp-abap-adt/transport      → Публічний scope
@fr0ster/mcp-abap-adt-server → Приватний scope (контрольований)
```

**Переваги:**
- ✅ Чітке розділення публічного та приватного
- ✅ Контроль через npm organization
- ✅ Гнучкість в управлінні доступом

**Реалізація:**
- Створити npm organization `@mcp-abap-adt` для публічних пакетів
- Використовувати `@fr0ster` scope для сервера
- Налаштувати доступ через npm teams

---

#### Стратегія 5: Feature flags + Публічний код

**Концепція:** Весь код публічний, але функціональність контролюється через конфігурацію

**Реалізація:**
- Всі пакети публічні
- Розширені функції доступні тільки з ліцензією
- Базовий функціонал доступний безкоштовно

**Переваги:**
- ✅ Максимальна простота інсталяції
- ✅ Контроль через feature flags
- ✅ Можливість монетизації преміум функцій

**Приклад:**
```typescript
// Базовий функціонал - безкоштовно
server.enableBasicFeatures();

// Преміум функції - з ліцензією
if (license.isValid()) {
  server.enablePremiumFeatures();
}
```

---

### Порівняльна таблиця стратегій

| Стратегія | Простота інсталяції | Контроль | Складність | Вартість |
|-----------|---------------------|----------|------------|----------|
| **Гібридний підхід** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | Середня | $7/міс (npm) |
| **Dual Licensing** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | Низька | Безкоштовно |
| **Runtime контроль** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | Висока | Залежить |
| **Scope-based** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | Середня | $7/міс (npm) |
| **Feature flags** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | Низька | Безкоштовно |

---

### Рекомендація для вашого випадку

**Найкращий варіант: Гібридний підхід (Стратегія 1)**

**Чому:**
1. ✅ **Connection/Transport/Utils** - публічні, прості в інсталяції
   - Користувачі можуть використовувати їх окремо
   - `npm install @mcp-abap-adt/connection` - працює відразу

2. ✅ **Server** - приватний або з обмеженнями
   - Контроль над основним продуктом
   - Можливість монетизації або обмеження доступу

3. ✅ **Гнучкість**
   - Можна змінити стратегію для server пізніше
   - Базові компоненти залишаються доступними

**Реалізація:**
```bash
# Публічні пакети
npm publish --access public @mcp-abap-adt/connection
npm publish --access public @mcp-abap-adt/transport
npm publish --access public @mcp-abap-adt/utils

# Приватний сервер
npm publish --access restricted @fr0ster/mcp-abap-adt-server
# або через GitHub Packages
```

**Альтернатива:** Якщо не хочете платити за приватні пакети, використайте **GitHub Packages** (безкоштовно для публічних репозиторіїв) або **Feature flags** підхід.

---

## Висновок

Розбиття на пакети має сенс для довгострокового розвитку проекту, особливо якщо планується перевикористання компонентів. Однак це значний рефакторинг, який займе 4-6 тижнів.

### Основні рекомендації:

1. **Розпочати з transport layer** (знизу вгору підхід):
   - Найнижчий рівень абстракції
   - Не залежить від connection або handlers
   - Використовується сервером, але не залежить від бізнес-логіки
   - Потім connection layer, потім utils, в кінці рефакторинг server

2. **Використати гібридний підхід для балансу:**
   - **Connection/Transport/Utils** → публічні npm пакети (проста інсталяція)
   - **Server** → приватний пакет або GitHub Packages (контроль розповсюдження)

3. **Архітектура з ізоляцією змін:**
   - Handlers залишаються в server, але використовують connection через інтерфейс
   - Зміни в handlers НЕ впливають на connection/transport
   - Можна імпортувати handlers для пакетного створення об'єктів

4. **Альтернативи безкоштовні:**
   - GitHub Packages (безкоштовно для публічних репозиторіїв)
   - Feature flags підхід (публічний код, контроль через конфігурацію)

### Щодо публічності та контролю:

Розбиття на пакети **не змінює автоматично публічність коду**, але дозволяє:
- ✅ Спростити інсталяцію базових компонентів (публічні пакети)
- ✅ Зберегти контроль над сервером (приватний пакет або ліцензування)
- ✅ Гнучко керувати доступом до різних компонентів

**Найкраще рішення:** Гібридний підхід з публічними базовими пакетами та контрольованим сервером через GitHub Packages (безкоштовно) або приватний npm пакет ($7/місяць).

